---
title: "TDD에 대해 고민한 사람들꺼 정리"
date: 2024-12-18
update: 2024-12-18
tags:
  - tdd
---

* 제 의견이 아닌 TDD에 대한 자료들을 정리했습니다.

## Bob Martin(클린 코드 저자)과 Jim Coplien이 테스트 주도 개발(TDD)에 대해 심층적으로 토론

출처

https://www.youtube.com/watch?v=eRxc4PD6RN0&ab_channel=%EB%8D%B0%EB%B8%8C%EC%9B%90%EC%98%81DVWY

### TDD의 가치

**Bob:** 

첫번째, 테스트 주도 개발자는 실패하는 단위 테스트를 작성하기 전까지는 한 줄의 상용 코드를 작성하지않는다.

두번째, 실패하기에 충분한 양의 단위테스트만 작성(컴파일이 안 되는 것도 실패에 해당)
따라서 실제로 동작하는 코드를 짜기 전에는 유닛 테스트 코드를 작성해야 한다.

세번째, 현재 실패하는 테스트 코드들을 성공시킬 만큼만 상용 코드를 작성해야 한다. 그러니깐 테스트 좀만 적어놓고, 그보다 많은 양의 상용코드를 작성할 수는 없다. 

이 세가지 주기는 30초마다 돌아간다. 결과적으로 테스트 코드와 상용 코드를 모두 작성하는 것을 의미한다.

**Jim:**

TDD에 대한 우려하는 상황은  

첫번째, 아키텍처나 프레임워크 없이 TDD를 사용한다는 것이다. 이는 TDD에 대해서 kent가 생각한 정의이다.
하지만, TDD를 사용해 아키텍처를 이끌어내야한다.

좀 더 쉽게 풀어서 설명해드리겠습니다.

1. TDD가 단위 테스트를 강조하다 보니, 자연스럽게 코드를 "절차적(procedural)"으로 작성하게 된다는 것입니다.
    - 예를 들어 "입력 X를 넣으면 Y가 나와야 한다"는 식의 테스트를 작성하게 됩니다.
    - 이는 마치 함수를 하나씩 테스트하는 전통적인 절차적 프로그래밍 방식과 비슷합니다.

2. 하지만 현대 소프트웨어는 "객체 지향적"으로 설계되어야 합니다.
    - 객체들은 서로 메시지를 주고받으며 상호작용합니다.
    - 각 객체는 자신만의 책임과 역할이 있고, 내부 상태를 가집니다.
    - 이는 단순한 입력→출력의 절차적 관계보다 훨씬 복잡합니다.

3. 따라서 Coplien은 TDD가 이런 "차원의 불일치"를 초래한다고 봅니다.
    - 2차원(절차적 테스트)으로 3차원(객체 간의 복잡한 상호작용)을 표현하려다 보니
    - 결국 좋은 객체지향 설계가 아닌, 절차적인 설계로 이끌린다는 것입니다.

쉽게 비유하자면:
- 레고로 집을 만든다고 생각해보세요.
- TDD는 각각의 레고 블록이 제대로 맞물리는지만 테스트하는 것과 비슷합니다.
- 하지만 실제 좋은 건축물을 만들려면 전체적인 구조와 공간의 활용을 고려해야 하죠.
- Coplien은 TDD가 이런 "큰 그림"을 놓치게 만든다고 우려하는 것입니다.

**Jim:**

따라서 이런 상황에서 리펙토링 하기란 매우 어렵다. 클래스 계층 전에 걸쳐 리펙토링을 해야 하기 때문에
같은 기능을 유지할 수 있다는 보장이 없다.

두번째 문제는 GUI가 무너진다. 절차적 아키텍처가 자바 클래스 래퍼 안에 들어가면서 더이상 시스템 구조를
도메인 지식이나 사용자의 개념 모델에 따라 이끌어 갈 수 없습니다.

좀 더 이해한 바로 정리했습니다.

1. GUI 애플리케이션은 보통 사용자의 관점과 도메인 개념을 반영해야 합니다.
    - 예를 들어 '주문' 화면이라면, 실제 비즈니스에서 주문이 어떻게 이루어지는지를 반영해야 합니다.
    - 사용자가 이해하는 방식대로 화면이 구성되어야 하죠.

2. 하지만 TDD의 절차적 접근이 이를 방해한다고 봅니다:
    - TDD로 인해 코드가 절차적으로 작성되면
    - 이 절차적 코드들이 Java 클래스들 안에 들어가게 되고
    - 결국 실제 비즈니스 도메인이나 사용자의 mental model과는 동떨어진 구조가 된다는 것입니다.

실제 예를 들어보면:
```java
// TDD로 인한 절차적 접근
class OrderProcessor {
    void validateInput() { ... }
    void calculateTotal() { ... }
    void processPayment() { ... }
    void saveOrder() { ... }
}

// 도메인 중심 접근
class Order {
    Customer customer;
    List<OrderItem> items;
    
    void placeOrder() {
        if (customer.canPlaceOrder()) {
            // 실제 비즈니스 로직
        }
    }
}
```

첫 번째 방식은 절차를 나열한 것이고, 두 번째 방식은 실제 비즈니스 개념을 반영한 것입니다.

Coplien은 TDD가 자연스럽게 첫 번째 방식으로 이끈다고 우려하는 것이죠. 이렇게 되면 실제 사용자나 비즈니스 전문가가 이해하는 방식과는 다른 구조가 만들어진다는 것입니다.

**Jim:**

아키텍처는 항상 GUI에 드러나게 된다. 그래서 저는 도메인 모델을 인터페이스에 반영할 수 있는 무언가가 필요하다고 생각한다.   
만약 내가 Bob의 세가지 법칙을 적용하면 아마도 큰 문제는 없을 것이다. 하지만 저는 아키텍처가 고려된 상태로 TDD를 시작하도록 원한다. 

TDD는 좋은 개발자가 되기 위해 필수적이지 않다.


**Bob:**

애자일 커뮤니티에선 아키텍처는 중요하지 않아한다. 단지 많은 테스트를 작성하, 많은 스토리를 작성하고
빠르게 반복해서 코드를 작성하면 코드가 스스로 조립될거라고 믿는 데 전혀 말도 안되는 소리이다.

kent에 물어보면 비슷하게 생각할것이다. 

나는 아키텍처에 매우 중요하게 생각한다. 그러나 아키텍처가 한 번에 완성된다고 믿지 않는다.
좋은 아키텍처기술을 통해 매번 반복하면 조금씩 구축된다고 믿는다. 그리고 초기 몇번의 반복동안
다양한 아키텍처형식을 실험하고나서 두 세번의 반복이 지나면 올바른 아키텍처로 잡게 될것이다.
그 다음 부터는 세부 조정단계 진입

아키텍처는 진화된다. 테스트코드도 포함

**Jim:**

작성하는 코드와 초기 단계의 사용 사례에 의해 형성된다고 믿는다.
하지만 도메인 지식없이 고객과의 상호작용만으로 점진적으로 일을 진행하려고하면 
완전히 잘못된 방향으로 갈거라고 생각한다.

은행만 생각해도 단순히 계좌를 시작해서 점진적 개발을 한다는 것은 말이안된다, 사실 은행은 입금,출금,다른은행으로 이전
등이 사용자 관점으로 살펴봐야 다르게 보인다.

따라서 초기부터 알고 있는 것들을 최대한 활용하고 중요한 결정을 미리 결정하면 이후의 결정들이 쉬워질것이다.
물론 상황은 변하고, 아키텍처는 진화한다.
불변하는 아키텍처를 정하자는 사람은 없을것이다.

또한 나는 테스트코드를 미리 작성하는것도 동의하지않는다.
도메인 지식을 구조화하는 인터페이스와 역할을 모두 선정한뒤에 클라이언트가 그 코드를 원하고 비용을 지불할
준비가 되있을때만 코드 구현을 하면된다.

구조를 미리 준비하지않으면 안된다.

**Bob:**

나는 다르게 생각한다. 인터페이스에 추상멤버함수나 불필요한 멤버함수를 채워넣지 않을것이다.
대신 인터페이스의 자리를 채울 객체를 생성할 것이다.

자바에서 흔히 쓰이는 interface에서 사용하지않을 메서드를 채우지 않을것이다. 이는 테스트와 요구사항이
이끌어갈 부분이다.

또한 인터페이스 구현과정에 아키텍처 문제가 없는지 주의를 기울어야한다.

**Jim:**

물론 추측하여 쓸모없는 것을 만들면 안된다.
하지만, 확실히 알고있는 것이 있다면 상황이 다르다. 예를들어 통신,은행 시스템 구조에 대해
알고있을수있다. 이럴땐 복구를 위한 객체를 만들면 안된다.

만약 그 객체의 멤버 함수가 무엇인지 이해하게 된다면 '복구'라는 것은 객체가 아님을 알게될것이다.
복구는 위험한 방식이고 객체에 의미를 부여할 무언가가 필요하다.

**Bob:**

동의한다. 

처음으로 돌아가 실행가능한 코드를 작성하기 전에 얼마나 시간을 쓸것인가요 결국 200만줄 코드가 될 시스템이라면?

**Jim:**

실제로 코드를 작성하기전에 시간을 쓰냐는건 시스템마다 다르다.
하지만 간단한 통신 시스템을 만든다고 가정했을 때 최소한 생성자와 소멸자는 작성해두고 객체 간의 중요한 관계를 연결할 수 있어야 한다.

그리고 그 연결을 테스트를 한다. 시스템이 올라오고 내려갈 때 메모리에 문제가 없는 지 확인하는 테스트를 하며 대략 30분 걸린다.

**Bob:**

좋다. 여기에는 이견이 없어보인다.

**Jim:**

사람들은 TDD를 교과서 그대로 적용하지 않고 BDD로 전환한 경우를 많이 본다. 

많은 개발자들이 착각하는게 시중에 나와있는 책에 있는 것처럼 그저 관련된 구식의 테스트나 아키텍처를 도입하는 것으로
완벽히 적용될 수 있다고 착각하는 것이다. 이건 말이 안된다.

프로페셔널한 정의를 세워보자

**Bob:**

유닛테스트없이 코드를 배포하는 개발자는 프로페셔널하지 않다. 이를 방지하는 방법은 TDD를 사용하는 것이다.

**Jim:**

나는 동의하지않는다. 

유닛테스트란 API의 프로시저를 검사하고 변수의 상태들을 확인한다. 몇 개 혹은 그 이상의 것을.
하지만 이런 방식은 매우 휴리스틱하고 버그를 찾으려면 정말 운이 좋아야한다.

제가 더 강력하다는 생각하는 것은 design by contract 이다. 사전조건,사후조건,불변 조건을 설정하는 것이다.
결국 이것이 TDD의 모든 장점을 가지고 있다고 생각한다. 

계약에 의한 설계가 테스트보다 효과적이다. 또한 더 넓은 범위를 커버할 수 있다.
이는 코드의 의도를 비즈니스 중요성과 연결할 수 있는 방식으로 표현한 것이다.

TDD는 대부분의 사람들이 클래스 수준에서 이를 실천하기 때문에 이러한 API를 클래스 수준에서 비즈니스 중요성까지 추적하기가 매우 어렵다.

**Bob:**

모든 메서드와 설계에 사전조건,사후조건,불변조건을 지정한 경험이 있다.
하지만 TDD나 일련의 단위테스트는 같은 방식이다 그래서 저는 계약을 단위테스트로, 단위테스트를 계약으로 변환할 수 있다고 생각한다.
단 의존성의 방향이 다르다는 점을 제외하고요. 

단, 단위테스트는 상용코드를 의존하지만 상용코드는 단위테스트에 의존하지 않는다. 하지만 계약조건은 코드 전체에 뿌려져있어 불편하게한다. 


**Jim:**

단위테스트를 사용하는 프로젝트는 코드양이 테스트양과 거의 같다. 코드가 있는 곳에는 버그가 있다.
게다가 개발 속도도 줄어든다.

하지만 Assertions를 적용하면 인터페이스의 의미와 코드 자체 간에 중요한 결합이 일어난다.
하지만 테스트와의 결합은 훨씬 더 혼란스럽고 어렵다.

---

## 켄트백이 쓴, TDD(테스트 주도 개발)에 대한 오해를 풀고 "진정한 TDD가 무엇인지" 설명하는 글

출처: https://tidyfirst.substack.com/p/canon-tdd


1. **TDD의 진정한 워크플로우**
   ```
   1. 테스트할 시나리오 목록 작성
   2. 목록에서 하나의 항목을 선택해 실제 실행 가능한 테스트로 작성
   3. 테스트가 통과하도록 코드 수정 (이전 테스트들도 모두 통과해야 함)
   4. 필요하다면 리팩토링
   5. 목록이 비워질 때까지 2번으로 돌아가 반복
   ```

2. **TDD의 목적**
    - 기존 기능이 계속 잘 작동하게 하면서
    - 새로운 기능도 예상대로 작동하게 하고
    - 다음 변경을 위한 준비가 된 상태로 만드는 것

3. **자주 하는 실수들**:
    - 구현 설계를 너무 일찍 고민하는 것 (테스트 목록 작성 단계에서는 하지 말 것)
    - 모든 테스트를 한번에 다 작성하는 것 (하나씩 해야 함)
    - 테스트를 통과시키려고 어설션을 지우는 것
    - 실제 계산된 값을 그대로 테스트의 예상값으로 복사-붙여넣기 하는 것
    - 리팩토링을 너무 일찍 하거나 너무 많이 하는 것

4. **중요한 구분**:
    - 인터페이스 설계 (어떻게 동작을 호출할 것인가)
    - 구현 설계 (어떻게 시스템이 그 동작을 실행할 것인가)
      이 두 가지는 분리해서 생각해야 합니다.

이 글의 요지는 "많은 사람들이 TDD라고 하면서 실제로는 다른 것을 하고 있다"는 것입니다. 그래서 TDD의 올바른 방법을 상세히 설명하고 있죠.





